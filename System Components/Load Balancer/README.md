# Load Balancer

![](./load%20balancer.drawio.png)

# Детали
## Типы-уровни балансировки
### L4 ~ Hardware LB
**Hardware LB** - осуществляет балансировку нагрузки на коммуникационно-информационную инфраструктуру:
* в зависимости от пропускной способности линий передачи информации;
* в зависимости от текущей загруженности трафиком;
* в зависимости от мощности обрабатывающего оборудования;
* и т.д...

Критически важные аспекты L4-балансировки:
1. Сохраняемость соединений (Persistence / Stickiness)  
    На L4 это реализуется через:
    * Source IP Hash (как описано выше)
    * Table-based persistence: Балансировщик запоминает пару (source_ip:port → backend_server) на время жизни соединения
    * Использование PROXY Protocol (для сохранения оригинального IP при прохождении через цепочку балансировщиков)

2. Health Checking на L4  
    Балансировщик проверяет бэкенды через:
    * TCP-connect check: Пытается установить TCP-соединение
    * TCP-request/reply: Отправляет какой-то payload и ждет ответ (например, для memcached/redis)
    * HTTP/HTTPS checks: Это уже L7, но многие L4-балансировщики умеют и это

L4-балансировщики часто включают:
* DDoS-защита на L4
* SYN flood protection
* Rate limiting по source IP
* Гео-блокировка
* Blackhole routing

### L7 ~ Software LB
**Software LB** - осуществляет балансировку нагрузки вычислительные мощности распределённой системы обработки информации.

## Алгоритмы балансировки
1. **Round Robin (Циклический перебор)**  
    Принцип: Запросы поочередно распределяются между серверами в списке.  
    Пример: Сервер A → Сервер B → Сервер C → Сервер A → ...  
    Плюсы: Простота, равномерное распределение при одинаковой мощности серверов.  
    Минусы: Не учитывает нагрузку серверов, текущее количество соединений, их производительность.  
    Когда использовать: Для однородных бэкендов без состояния.  

2. **Weighted Round Robin (Взвешенный циклический)**  
    Принцип: Как Round Robin, но каждому серверу присваивается вес (weight). Сервер с весом 3 получит в 3 раза больше запросов, чем сервер с весом 1  
    Пример: Вес 3:2:1 → A, A, A, B, B, C, A, A, A, B, B, C...  
    Плюсы: Учитывает разную производительность серверов (новые мощные серверы получают больший вес).  
    Минусы: Статические веса, не адаптируются к реальной нагрузке.  
    Когда использовать: При неоднородном железе (разные CPU/RAM).  

3. **Least Connections (Наименьшее количество соединений)**  
    Принцип: Новое соединение направляется на сервер с наименьшим текущим числом активных соединений.  
    Плюсы: Динамически адаптируется к нагрузке, хорошо для long-lived соединений (WebSocket, базы данных, gRPC streaming).  
    Минусы: Требует отслеживания состояния всех соединений, дополнительная нагрузка на балансировщик.  
    Вариант: Weighted Least Connections — учитывает и вес серверов.  
    Когда использовать: Для сервисов с разным временем обработки запросов или постоянными соединениями.  

4. **Source IP Hash (Хеширование по IP источника)**  
    Принцип: Хеш от IP-адреса клиента определяет, на какой сервер пойдет трафик. Один и тот же клиент всегда попадает на один и тот же сервер (при неизменном списке бэкендов).  
    Плюсы: Гарантирует session persistence (полезно, если сервер хранит состояние сессии локально, хотя это anti-pattern для микросервисов).  
    Минусы: Может создавать дисбаланс, если несколько крупных клиентов (NAT, прокси) попадут на один сервер.  
    Когда использовать: Для legacy-систем с stateful-бэкендами или когда важно сохранить affinity.  

5. **Destination IP Hash (Хеширование по IP назначения)**  
    Принцип: Используется в цепочке балансировщиков. Второй балансировщик выбирает сервер на основе IP-адреса, полученного от первого.  
    Когда использовать: Для сложных многоуровневых архитектур.  

6. **Random (Случайный выбор)**  
    Принцип: Сервер выбирается случайным образом.  
    Плюсы: Простота, в теории дает равномерное распределение при большом количестве запросов.  
    Минусы: Может возникать временный дисбаланс.  
    Вариант: Weighted Random — случайный выбор с учетом весов.  
    Когда использовать: В высоконагруженных системах, где overhead отслеживания соединений слишком велик.  

## Специальные алгоритмы для L4
1. **Fastest Response Time (Наименьшее время отклика)**
    Принцип: Балансировщик измеряет время отклика серверов (ping, health check) и отправляет запрос на самый быстрый.  
    Плюсы: Учитывает реальную производительность сервера.  
    Минусы: L4-балансировщик не всегда может точно измерить время отклика приложения (только TCP-connect time).  
    Когда использовать: Для географически распределенных дата-центров.  

2. **Maglev (от Google)**  
    Принцип: Продвинутый алгоритм хеширования, минимизирующий перераспределение при добавлении/удалении серверов (consistent hashing с улучшениями).  
    Плюсы: Минимальная перебалансировка, высокая скорость работы.  
    Минусы: Сложная реализация.  
    Когда использовать: В очень крупных системах (используется в Google Cloud и внутренних системах Google).  

3. **Power of Two Choices (P2C)**  
    Принцип: Для каждого запроса случайно выбираются два сервера, а затем запрос направляется на тот, у которого меньше активных соединений.  
    Плюсы: Хороший компромисс между производительностью (не нужно отслеживать все серверы) и качеством балансировки.  
    Минусы: Слегка хуже, чем Least Connections.  
    Когда использовать: В системах, где нужно снизить нагрузку на балансировщик.  

# Известные LB
1. Pacemaker
2. Nginx
3. KeepAlived
4. Haproxy
5. Kubernetes
