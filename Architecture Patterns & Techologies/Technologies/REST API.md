# REST API

**REST (Representational State Transfer — «передача состояния представления»)** был предложен Роем Филдингом в его диссертации в 2000 году.  
Его ключевая идея: сервер предоставляет представления ресурсов, а клиент, манипулируя этими представлениями, изменяет состояние ресурса на сервере.

---

**REST API** — это:
- архитектурный стиль (набор принципов и ограничений, а не протокол, стандарт или паттерн), который описывает, как клиенты и серверы должны взаимодействовать через HTTP.
- доминирующий стандарт для построения веб-сервисов, который использует простоту и универсальность HTTP для создания понятных, масштабируемых и независимых от клиента интерфейсов. Его популярность обусловлена простотой освоения и идеальным соответствием архитектуре современного веба.

**REST API существует поверх [протокола HTTP(S)](./HTTP(S).md) (это фундаментальный момент)**:
- REST использует HTTP не просто как транспорт, а как прикладной протокол, задействуя всю его семантику:
    - Методы (Verbs): GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS.
    - URL (Nouns): Уникальные идентификаторы ресурсов.
    - Коды состояния (Status Codes): 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 500 Internal Server Error.
    - Заголовки (Headers): Для кэширования (Cache-Control), определения типа контента (Content-Type), аутентификации (Authorization).
    - Тело запроса/ответа (Body): Содержит представление ресурса (обычно JSON, реже XML или другие форматы).

## Ключевые принципы REST (ограничения архитектуры)
1. **Единообразие интерфейса (Uniform Interface) (самый важный принцип)**:
    - **Ресурсы**  
        Все сущности (пользователь, заказ, товар) представляются как уникально идентифицируемые ресурсы (обычно через URL, например, /api/users/123).
    - **Манипуляция ресурсами через представления**  
        Клиент работает с ресурсом через его представление (например, JSON или XML).  
        Получив представление, клиент может изменить или удалить ресурс.
    - **Самодостаточные сообщения**  
        Каждый запрос от клиента содержит всю информацию, необходимую серверу для его обработки (URL, метод, заголовки, тело).
    - **HATEOAS (Hypermedia as the Engine of Application State)**  
        Идеальный REST предполагает, что клиент начинает со стартовой точки API, а все дальнейшие действия определяются гиперссылками, которые сервер предоставляет в ответах (как на веб-страницах) (на практике это используется редко).
2. **Клиент-серверная архитектура $\simeq$ Четкое разделение обязанностей**
3. **Отсутствие состояния (Stateless)**  
    Сервер не хранит состояние клиента между запросами.  
    Каждый запрос независим и содержит все необходимые данные (аутентификация, параметры).
4. **Кэшируемость (Cacheable)**  
    Ответы сервера должны явно указывать, можно ли кэшировать данные и как долго.
5. **Слоистая система (Layered System)**  
    Архитектура может состоять из нескольких слоев (балансировщики, прокси, шлюзы), и клиент не знает, подключен ли он напрямую к серверу или через промежуточное звено.
6. **Код по требованию (Code on Demand, опционально)**  
    Сервер может временно расширять функциональность клиента, передавая ему исполняемый код (например, JavaScript) (используется редко).


## Уровни зрелости и стили REST API

Уровни зрелости REST API по модели Ричардсона (Richardson Maturity Model):
- Уровень 0: Использование HTTP как транспортного туннеля для своих RPC-вызовов  
    Обычно один endpoint, например `/api`, и все действия описываются в теле запроса  
    Это НЕ REST.  
- Уровень 1: Появление ресурсов  
    Разные URL для разных сущностей, например `/api/users` и `/api/orders`.
- Уровень 2: Использование HTTP-методов по их семантике и кодов состояния (практически большинство публичных API)  
    GET для чтения  
    POST для создания  
    PUT для полного обновления  
    DELETE для удаления
- Уровень 3: Внедрение HATEOAS  
    Ответы API содержат гиперссылки на возможные следующие действия (например, в ответе о заказе есть ссылки "self", "cancel", "pay").

Стили REST API стилю:
- RESTful API (истинный REST):  
    Строго следует всем принципам, включая HATEOAS.
- REST-like API (практический REST):  
    Следует ключевым принципам (ресурсы, HTTP-методы, коды ответов), но опускает HATEOAS.  
    Именно так устроено 95% API, которые называют «REST API».

## Применение REST API

Идеально подходит для систем, где:
* Нужна публичная интеграция: Открытые API для мобильных приложений, веб-сайтов, партнеров.
* Масштабируемость критична: Благодаря stateless-природе легко масштабировать, добавляя новые серверы.
* Простота и понятность важны: Использование стандартных HTTP-методов и структур URL интуитивно понятно для разработчиков.
* Кросс-платформенность: Любой клиент, понимающий HTTP (браузер, мобильное приложение, IoT-устройство), может работать с REST API.
* Распределенные системы и микросервисы: REST — стандартный способ коммуникации между независимыми сервисами.

Где может НЕ подходить:
* Системы реального времени (чат, онлайн-игры): Для них лучше подходят WebSockets или gRPC.
* Системы, где важна минимальная задержка и высокая производительность: Двоичные протоколы (gRPC, Apache Thrift) могут быть эффективнее.
* Сложные операции с множеством вызовов: Для задач, требующих транзакций или сложных последовательностей действий, один вызов SOAP или GraphQL-запрос может быть лучше, чем несколько REST-запросов.
