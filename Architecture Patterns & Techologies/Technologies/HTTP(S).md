# HTTP(S)
**HTTP (HyperText Transfer Protocol — протокол передачи гипертекста)** — это:
- прикладной протокол (Application Layer);
- простой текстовый протокол (в версии 1.1), который стал основой современного веба благодаря своей простоте и расширяемости, а HTTPS сделал его безопасным, что критически важно в современном интернете;
- 80 порт в TCP/UDP.

**HTTPS (Security)** — это:
- HTTP, работающий поверх дополнительного слоя шифрования SSL/TLS, который находится между транспортным (TCP) и прикладным (HTTP) уровнями;
- 443 порт в TCP/UDP.

[WiKi](https://ru.wikipedia.org/wiki/HTTP#%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_HTTP-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F)

---

В модели TCP/IP (более практичная):
* Прикладной уровень (Application): HTTP, HTTPS, FTP, SMTP, DNS
* Транспортный уровень (Transport): TCP, UDP
* Сетевой уровень (Internet): IP
* Канальный уровень (Link): Ethernet, Wi-Fi

В модели OSI (7 уровней):
* L-7 Прикладной (Application): HTTP — здесь**
* L-6 Представительский (Presentation): SSL/TLS (для HTTPS)
* L-5 Сеансовый (Session): SSL/TLS управляет сессиями
* L-4 Транспортный (Transport): TCP
* L-3 Сетевой (Network): IP
* L-2 Канальный (Data Link): Ethernet
* L-1 Физический (Physical): Кабели, радиоволны

<details>
<summary>Типичный стек протоколов для запроса к сайту</summary>

```
HTTP/HTTPS (Прикладной)
    ↓
TLS (для HTTPS) (Безопасность)
    ↓
TCP (Транспортный)
    ↓
IP (Сетевой)
    ↓
Ethernet/Wi-Fi (Канальный/Физический)
```
</details>

<details>
<summary>Пример установки соединения</summary>

```
Этап-1: TLS handshake (только для HTTPS): Обмен ключами, аутентификация сервера
Этап-2: TCP handshake: Установка надежного соединения (SYN → SYN-ACK → ACK)
Этап-3: HTTP запрос: Клиент отправляет HTTP-сообщение
Этап-4: HTTP ответ: Сервер возвращает ответ
```
</details>

## Структура протокола

Структура HTTP-запроса:
```txt
МЕТОД ПУТЬ ВЕРСИЯ
Заголовки...
Пустая строка
Тело (для POST/PUT)
```

<details>
<summary>Пример HTTP-запроса</summary>

```txt
# Ethernet заголовок (14 байт) - ВСЕГДА 14 БАЙТ
00 1A 2B 3C 4D 5E  # MAC назначения (6 байт)
00 0C 29 1F 8E 4A  # MAC источника (6 байт)
08 00              # Тип: IPv4 (0x0800) (2 байта)

# IP заголовок (20 байт, IPv4) - МИНИМУМ 20 БАЙТ
45 00 00 54        # Версия=4, IHL=5, Total Length=84 bytes (60+24)
1C 46 40 00        # ID, Flags, Fragment Offset
80 06 00 00        # TTL=128, Protocol=TCP (6), Header Checksum
C0 A8 01 64        # Source IP: 192.168.1.100
D8 3A D3 2E        # Dest IP: 216.58.211.46

# TCP заголовок (20 байт) - МИНИМУМ 20 БАЙТ
C9 5C              # Source Port: 51548
00 50              # Dest Port: 80 (HTTP)
12 34 56 78        # Sequence Number
90 12 34 56        # Acknowledgement Number
50 18 01 00        # Data Offset=5 (20 bytes), Flags=PSH+ACK, Window=256
FA F0 00 00        # Checksum, Urgent Pointer

# HTTP данные (сам запрос) - 43 байта (а не 12!)
47 45 54 20 2F 20 48 54 54 50 2F 31 2E 31 0D 0A   # "GET / HTTP/1.1\r\n"
48 6F 73 74 3A 20 65 78 61 6D 70 6C 65 2E 63 6F   # "Host: example.co"
6D 0D 0A                                          # "m\r\n"
55 73 65 72 2D 41 67 65 6E 74 3A 20 54 65 73 74   # "User-Agent: Test"
0D 0A                                             # "\r\n"
0D 0A                                             # "\r\n" (конец заголовков)
```
</details>

---

Структура HTTP-ответа:
```txt
ВЕРСИЯ КОД_СТАТУСА ПОЯСНЕНИЕ
Заголовки...
Пустая строка
Тело (для POST/PUT)
```

<details>
<summary>Пример HTTP-ответа:</summary>

```txt
# Ethernet (14 байт) - ответ от сервера к клиенту
00 0C 29 1F 8E 4A  # MAC назначения: клиент
00 1A 2B 3C 4D 5E  # MAC источника: сервер
08 00              # Тип: IPv4

# IP заголовок (20 байт)
45 00 01 2D        # Total Length: 301 bytes (20+20+261)
... остальные поля IP ...
C0 A8 01 64        # Source IP: сервер
D8 3A D3 2E        # Dest IP: клиент

# TCP заголовок (20 байт)
00 50              # Source Port: 80 (HTTP)
C9 5C              # Dest Port: 51548 (клиентский порт)
90 12 34 56        # Sequence Number (ответное)
12 34 56 79        # Acknowledgement Number
50 18 01 00        # Флаги
... чексумма ...

# HTTP ОТВЕТ (261 байт) - ВНИМАНИЕ СЮДА!
48 54 54 50 2F 31 2E 31 20 32 30 30 20 4F 4B 0D 0A                                                                          # "HTTP/1.1 200 OK\r\n"
53 65 72 76 65 72 3A 20 6E 67 69 6E 78 2F 31 2E 31 38 2E 30 0D 0A                                                           # "Server: nginx/1.18.0\r\n"
44 61 74 65 3A 20 4D 6F 6E 2C 20 32 33 20 4A 61 6E 20 32 30 32 33 20 31 30 3A 30 30 3A 30 30 20 47 4D 54 0D 0A              # "Date: Mon, 23 Jan 2023 10:00:00 GMT\r\n"
43 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 20 74 65 78 74 2F 68 74 6D 6C 3B 20 63 68 61 72 73 65 74 3D 75 74 66 2D 38 0D 0A     # "Content-Type: text/html; charset=utf-8\r\n"
43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 31 32 35 36 0D 0A                                                           # "Content-Length: 1256\r\n"
43 6F 6E 6E 65 63 74 69 6F 6E 3A 20 6B 65 65 70 2D 61 6C 69 76 65 0D 0A                                                     # "Connection: keep-alive\r\n"
0D 0A                                                                                                                       # "\r\n" (КОНЕЦ ЗАГОЛОВКОВ!)

# Тело ответа (HTML) - 1256 байт
3C 21 44 4F 43 54 59 50 45 20 68 74 6D 6C 3E 0A  # "<!DOCTYPE html>"
3C 68 74 6D 6C 3E 0A 3C 68 65 61 64 3E 0A 3C 74  # "<html><head><t"
69 74 6C 65 3E 45 78 61 6D 70 6C 65 3C 2F 74 69  # "itle>Example</ti"
... и так далее 1256 байт HTML ...
```
</details>

---

<details>
<summary>Алгоритм чтения бинарных HTTP-данных</summary>

```txt
Найти начало HTTP-данных в TCP payload
Прочитать первые байты как ASCII:
    47 45 54 = "GET"
    50 4F 53 54 = "POST"
    48 54 54 50 = "HTTP" (для ответов)
Искать последовательность 0D 0A 0D 0A = \r\n\r\n — конец заголовков
После этого — тело сообщения
```
</details>

## Ключевые концепции HTTP

### Методы
HTTP методы определяют действие, которое нужно выполнить с ресурсом. Это ключевая часть семантики REST.
Основные методы (используются в 99% случаев):
1. GET — получение данных
    - Назначение: Запросить представление ресурса
    - Идемпотентность: Да (многократный вызов дает тот же результат)
    - Безопасность: Да (не изменяет состояние сервера)
    - Тело запроса: Обычно отсутствует
    - Пример: GET /api/users/123
    - Коды ответов: 200 OK, 404 Not Found, 304 Not Modified

2. POST — создание или сложная обработка
    - Назначение: Создать новый ресурс или отправить данные для обработки
    - Идемпотентность: Нет (каждый вызов создает новый ресурс)
    - Безопасность: Нет
    - Тело запроса: Есть (данные для создания)
    - Пример: POST /api/users с телом {"name": "John"}
    - Коды ответов: 201 Created, 400 Bad Request

3. PUT — полное обновление
    - Назначение: Заменить ресурс целиком
    - Идемпотентность: Да (многократный вызов дает тот же результат)
    - Безопасность: Нет
    - Тело запроса: Есть (новое состояние ресурса)
    - Пример: PUT /api/users/123 с полным описанием пользователя
    - Коды ответов: 200 OK, 204 No Content, 404 Not Found

4. PATCH — частичное обновление
    - Назначение: Изменить часть ресурса
    - Идемпотентность: Не всегда (зависит от реализации)
    - Безопасность: Нет
    - Тело запроса: Есть (только изменяемые поля)
    - Пример: PATCH /api/users/123 с {"age": 30} (только возраст)
    - Коды ответов: 200 OK, 204 No Content

5. DELETE — удаление
    - Назначение: Удалить ресурс
    - Идемпотентность: Да (после первого удаления ресурса нет)
    - Безопасность: Нет
    - Тело запроса: Обычно отсутствует
    - Пример: DELETE /api/users/123
    - Коды ответов: 204 No Content, 200 OK, 404 Not Found

Дополнительные методы:

6. HEAD — получение заголовков
    - Как GET, но без тела ответа
    - Используется для проверки существования ресурса или метаданных

7. OPTIONS — информация о возможностях
    - Получить список поддерживаемых методов для ресурса
    - Важно для CORS (кросс-доменные запросы)

8. CONNECT, TRACE
    - Используются редко, в основном для отладки и туннелирования

### Заголовки (Headers):
[Стандартные (RFC) заголовки](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers):
1. Формат данных: `Content-Type: application/json`
0. Аутентификация: `Authorization: Bearer token123`
0. Кэширование: `Cache-Control: max-age=3600`
0. Информация о клиенте: `User-Agent: Mozilla/5.0`
0. и другие... (количество не ограничено)

Можно создавать собственные с префиксом X- (по соглашению):
- X-Custom-Header: myvalue
- X-API-Key: abc123
- X-Request-ID: 78910

### Коды состояния (Status Codes):
1. `1xx` — Информационные: 100 Continue, 101 Switching Protocols
0. `2xx` — Успех: 200 OK, 201 Created, 204 No Content
0. `3xx` — Перенаправление: 301 Moved Permanently, 304 Not Modified
0. `4xx` — Ошибка клиента: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
0. `5xx` — Ошибка сервера: 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable

## Где и как используется?
1. Передача веб-ресурсов:
   * HTML-страниц
   * CSS-стилей
   * JavaScript-файлов
   * Изображений, видео, аудио
   * Шрифтов
2. Взаимодействие с веб-сервисами (API):
   * REST API (как мы обсуждали ранее)
   * Загрузка и отправка данных форм
   * AJAX-запросы
3. Управление веб-сессиями:
   * Аутентификация и авторизация (куки, токены)
   * Корзины покупок
   * Персонализированный контент
4. Кэширование и оптимизация:
   * Контроль кэширования на стороне клиента и прокси
   * Условные запросы (If-Modified-Since)
5. HTTPS добавляет критически важные функции:
   * Шифрование данных — защита от перехвата
   * Аутентификация сервера — уверенность, что вы общаетесь с настоящим сайтом
   * Целостность данных — защита от подмены содержимого
   * Доверие пользователей — зеленый замочек в браузере
   * SEO-преимущества — Google ранжирует HTTPS-сайты выше

## Версии
* HTTP/1.1 (1999) — текущий стандарт, поддерживает persistent connections
* HTTP/2 (2015) — бинарный, мультиплексирование, сжатие заголовков
* HTTP/3 (внедряется) — поверх QUIC (UDP вместо TCP), лучше для мобильных сетей