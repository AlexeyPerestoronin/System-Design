# System Design

![](./think%20about%20system%20roadmap.drawio.png)

# Детали

## 1. Функциональные требования (ФТ)

**Функциональные требования = "что нужно сделать?"** - это фиксация требования через ответы на вопросы, которые **можно запрограммировать**:
1. Что нужно сделать?
    1. в какой среде работает система?
    0. с данными каких типов работает система?
    0. каковы сценарии использования?
    0. что ожидается на входе и выходе?
    0. как должна вести себя система в тех-то и тех-то случаях?
    0. как система должна реагировать на различного рода ситуации?
    0. как система обрабатывает возникающие ошибки?

## 2. Нефункциональные требования (НФТ)

**Нефункциональные требования (свойства)** - это фиксация требований системы через ответы на вопросы, которые **нельзя прямо запрограммировать**:
1. Как должно работать?
    1. какова ожидаемая степень доступности?
    0. каков необходимый класс надёжности?
    0. какова ожидаемая степень отказоустойчивости?
    0. какова ожидаемая степень масштабируемости?
    0. какой объём аналитики необходимо собирать?
0. Какие есть ограничения?
    1. в каких ограничения будет функционировать система?
    0. каковы ограничения на время/ресурсы?
    0. какое минимальное время отклика?
    0. какая предполагается среда функционирования?
0. Какие ключевые метрики?
   1. DAU/WAU/MAU = Daily/Weekly/Monthly Active User - количество ожидаемых активных пользователей за определённый период
   0. Количество пользователей через 5 лет
   0. Количество операций пользователем в день
   0. RPS = количество запросов в систему в секунду
   0. Объём сетевого трафика за минуту/день/месяц
   0. CPU = минимальные/ожидаемые/перспективные вычислительные мощности
   0. HDD/SDD = минимальные/ожидаемые/перспективные объёмы файловых хранилищ различных типов
   0. HDD/SDD+ = минимальные/ожидаемые/перспективные объёмы увеличения хранимых данных за период (д.м.г.)
   0. Какова минимальная и максимальная оценка стоимости системы
0.  Какова матрица приоритетности?
![](./priority%20matrix.drawio.png)
    1. **Agility** - способность быстро адаптироваться под постоянно меняющиеся бизнес-требования.
    0. **Configurability** - способность быстро адаптировать под решение конкретных зад.
    0. **Availability** - качество способности быть доступной (например 99% времени в секундах в год).
    0. **Information Security** -  качество способности хранить и передавать информацию в защищённом виде.
    0. **Maintainability** -  качество способности быть легко поддерживаемой _на плаву_.
    0. **Hight Throughput** - качество способности обрабатывать максимальное количество запросов.
    0. **Low Latency** - качество способности по обработки единичного запроса за минимальное время.
    0. **Usability** - качество способности толерантности к пользовательскому опыту.
    0. **Testability** - качество способности быть легко тестируемой. 
    0. **Elasticity** - способность быстро адаптироваться под постоянно меняющуюся нагрузку.

## 3. Выбор целевой архитектуры

# Нюансы

## Что следует учесть при заработке сервисной системы
1. DNS? - нужно ли отдельное доменное имя
2. Администрирование? - внутреннее или внешнее через выделенный сервис (возможно общий на систему) 
3. Мониторинг? - нужен ли отдельный сервис под мониторинг
4. Логирование? - нужен ли отдельный сервис под логирование
5. Аутентификация? - нужен ли отдельный сервис под аутентификацию пользователей системы (возможно, разный для разных пользователей)
6. Масштабирование? - нужно ли закладывать ресурсы на масштабирование системы
    1. Вертикальное - через увеличение мощности серверов
    2. Горизонтальное - через увеличения количества серверов
7. Кэширование? - критично ли кеширование и на какой стороне
    1. Client caching - расположение данных на машине клиента
    2. CDN caching (CDN = Content Delivery Network) - территориально-серверная оптимизация расположения данных
    3. Web server caching = Varnish - ускоритель HTTP
    4. Database caching - создание отдельных таблиц для быстрого доступа с определённым данным
    5. Application caching - кэширование данных времени выполнения
8. [Load Balancer](./load%20balancer/README.md)? - критично ли балансирование нагрузки и какими методами
    1. L-4: на уровне транспортных протоколов
    2. L-7: на уровне приложения
9.  Database Prioritizing? - насколько критичны данные для работы сервиса или ключевым аспектом является логика работы
    1. [Выбор СУБД через классификацию](./data%20bases/README.md)
10. Какой способ интеграции с другими компонентами системы (внешними системами)
    1. File System (через файловую систему)
    2. DB (через базу данных)
    3. Web (при помощи какой-то сетевой технологии/паттерна)
        1. **REST API**
        2. **AsyncAPI - асинхронный или неблокирующий API** - интерфейс прикладного программирования, который позволяет (1) отправлять несколько запросов одновременно (2) и интеллектуально управлять соединениями между сервисами не дожидаясь ответа.
        3. **(Web)Socket** - принцип межсетевой коммуникации между системами, основанный на установлении устойчивого канала обмена данными на время соединения.  
            Исторически основан на WebSocket - протоколе связи поверх TCP протокола.  
            Хорошо подходит для коммуникаций между системами реального времени. 
        4. **SSE = Server-Sent Event** - технология отправки уведомлений от сервера к клиенту в виде DOM-событий.  
            Данная технология позволяет менять DOM-структуру рабочего документа (как правило, это web-страница) без необходимости обратного ответа со стороны клиента (push-уведомления, контекстная реклама и т.д.).  
        5. **Long Request ~ Длинный опрос** - поход web-интеграции, при котором клиент, запрашивая сервер, получает немедленный ответ вместе с уникальным URL-адресом состояния, опрашивая который, клиент может получить актуальный статус-прогресс готовности результата запроса.
        6. **URL-обратного вызова** - подход web-интеграции, при котором клиент, отправив запрос, получает от сервера немедленный ответ с уникальным URL-адресом обратного вызова, по которому клиент может найти ответ, когда тот будет сформирован. Важно, что клиенту нет необходимости постоянно опрашивать полученный адрес, проверяя готовность, результата, т.к. сервер уведомит клиента, когда таковой результат будет доступен к получению.
        7. **Message Queue** - метод, при котором интеграция между компонентами системы происходит через очередь сообщений.
        8. **Message Broker** - метод, при котором интеграция между компонентами системы происходит через брокер сообщений, который берёт на себя множество посреднических функций:  
            (1) проверка сообщения на ошибки;  
            (2) маршрутизация конкретному приёмнику;  
            (3) разбиение на сообщения на порции, распределение по обработчиками с последующим агрегированием в ответе;  
            (4) сохранение сообщений в БД;  
            (5) распространение сообщений по подписчикам (издатель-подписчик).  
        9. **WebHook** - способ интеграции, когда два и более компонентов системы резервируют в режиме ожидания какой-либо канал связи с регистрацией обработчика события его активации.  
            Подобный подход позволяет обмениваться сообщениями в режиме реального времени (как правило, это похоже на уведомление с требованием ответа, например, когда сервис посылает продавцу уведомление о том, что клиент оплатил заказ).
        10. **RPC = Remote Procedure Control** - класс технологий, позволяющих программам вызывать функции или процедуры в другом адресном пространстве (на удалённых узлах либо в независимой сторонней системе на том же узле).  
            Наиболее хорошо подходит для организации распределённых систем в которых должна обеспечиваться моментальная интерактивная связь между компонентами в условиях малых объёмов передаваемых данных.  
        11. **GraphQL** - это спецификация для языка запросов данных и языка манипулирования данными, предназначенный для построения web-ориентированных программных компонентов.  
            Рекомендуется к использованию, когда:  
            (1) необходимо уменьшить количество запросов, выполняемых с клиента;  
            (2) необходимо избежать денормализации данных требуемой лишь для того, чтобы оптимизировать работу механизма построения пользовательских интерфейсов;  
            (3) есть проблема наличия множественных источников информации, запосы к которым приходится агрегировать в рамках одного обращения клиента;  
            (4) есть проблема множественных точек достпа к системе со стороны клиента, каждая из которых требует уникального сервера (отдельного REST API) для доступа к данным системы.  
            Заметка: наличие в системе GrapthQL возможностей, подразумевает наличие GrapthQL-Server в качестве отдельного компонента (который, как правило, действительно является отдельным серверным компонентом серверной системы).